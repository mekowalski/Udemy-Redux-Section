OBJECT-BASED REDUCERS

-Reducer Structure Option #1
-Common(and most current way I've created) Reducers, for a list of records to maintain
-Always returned an array of objects
streamsReducer ---> [ stream | stream | stream | stream ]


-Take a different approach to maintain an array of objects
-Reducer Structure Option #2
-Still have a certain Reducer that would behave as a Reducer would
-Add Reducer to combineReducers call
-Instead of returning an array of records, it will return an object
-This object will have all the records inside of it
-Object will also have Key-Value pairs, (key: record ID, value: record with that matching ID)
  eg:
  streamsReducer ---> {
                        KEY | VALUE
                        3:  | stream w/ ID 3
                        27: | stream w/ ID 27
                        39: | stream w/ ID 39
                      }


-In order to access a given record, reference the record's piece of State out of Redux Store, then access
 appropriate ID inside, which will give the record being requested
-Updating/modifying will also be much simpler to do

-Replacing an element in an array would be applied any time the Action Creator for editing
-Whenever an edit Action Creator is called, it would be an attempt to updating a record on the API
  1. Make the request to update the record
  2. Then get the updated record back as the response from API
  3. THEN, dispatch an action with type `EDIT_RECORD`(whatever the action name is), with payload
-When the updated record is returned, want to PROBABLY find the original record with identical ID inside
 Reducer and remove old record and replace it in the payload propertyd
 eg: Updating an Object
 { ...state, id: 6}
 1. Put {} to indicate a new object
 2. Take all records out of old State object(...state) and add it in
 3. Then add in a new K-V pair(id: 6)


EXAMPLES OF UPDATING
-Array-Based Approach
const streamReducer = (state=[], action) => {
  switch (action.type) {
    case EDIT_STREAM:

    default:
      return state
  }
}
