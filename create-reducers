Dispatch is part of Redux Library, therefore that doesn't have to be written from scratch
Skip over Dispatch and implement Reducers

-Reducers: write a few function to model a Dept in the Insurance Co
1. Claims Reducer
2. Accounting Reducer
3. Policies Reducer

-Each Reducer will be called with an Action(Form)
-Reducer will inspect the Action(Form) and decide whether or not it needs to modify data based on Action
-Each Reducer is passed 2 pieces of arguments in the same order
  1. Whatever existing Data from Data Bank belongs to the Dept
  2. Action(Form)

-Reducer is a Function, not knowing what its data is until it is called for the first time
-Make sure to handle the case when a Reducer is called for the very first time
-There will be no data, not previous list of claims to be passed in
-The first time the Reducer is called, it will receive the value of 'undefined'
-Default value of first argument with an empty array instead of undefined

eg: Claims History
//REDUCERS(Departments)
const claimsHistory = (oldClaims = [], action) => {
  if (action.type === 'CREATE_CLAIM') {
    //we care about this action (Form)
    return [...oldClaims, action.payload]
    //ES15 syntax, takes original array, add it to brand new array then add the new record(action.payload)
  }
  //then we don't care about the action (Form)
  return oldClaims
}

//Console
const numbers = [1, 2, 3] => undefined
[...numbers, 4] => (4)Â [1, 2, 3, 4]

***Anytime a record is changed inside Reducers, always always always, 100% of the time, want to return a
   new array/object, as oppposed to modifying an existing structure***
***.push will never be inside a Redcuer as that will MODIFY the existing structure***


eg: Accounting
const accounting = (currentMoney = 100, action) => {
   if (action.type === 'CREATE_CLAIM') {
     return currentMoney - action.payload.amountToCollect
   }

   else if (action.type === 'CREATE_POLICY') {
     return currenMoney + action.paylod.amount
   }

   return currentMoney
}


eg: Policies
const policies = (existingPolicies = [], action) => {
  if (action.type === 'CREATE_POLICY') {
    return [...existingPolicies, action.payload.name]
  }

  else if (action.type === 'DELETE_POLICY') {
    return existingPolicies.filter(name => name !== action.payload)
  }

  return exitingPolicies
}
